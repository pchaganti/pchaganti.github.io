{
  "last_updated": "2025-07-09T11:13:19.369221-04:00",
  "papers": [
    {
      "title": "RSRefSeg 2: Decoupling Referring Remote Sensing Image Segmentation with\n  Foundation Models",
      "summary": "Referring Remote Sensing Image Segmentation provides a flexible and\nfine-grained framework for remote sensing scene analysis via vision-language\ncollaborative interpretation. Current approaches predominantly utilize a\nthree-stage pipeline encompassing dual-modal encoding, cross-modal interaction,\nand pixel decoding. These methods demonstrate significant limitations in\nmanaging complex semantic relationships and achieving precise cross-modal\nalignment, largely due to their coupled processing mechanism that conflates\ntarget localization with boundary delineation. This architectural coupling\namplifies error propagation under semantic ambiguity while restricting model\ngeneralizability and interpretability. To address these issues, we propose\nRSRefSeg 2, a decoupling paradigm that reformulates the conventional workflow\ninto a collaborative dual-stage framework: coarse localization followed by fine\nsegmentation. RSRefSeg 2 integrates CLIP's cross-modal alignment strength with\nSAM's segmentation generalizability through strategic foundation model\ncollaboration. Specifically, CLIP is employed as the dual-modal encoder to\nactivate target features within its pre-aligned semantic space and generate\nlocalization prompts. To mitigate CLIP's misactivation challenges in\nmulti-entity scenarios described by referring texts, a cascaded second-order\nprompter is devised, which enhances precision through implicit reasoning via\ndecomposition of text embeddings into complementary semantic subspaces. These\noptimized semantic prompts subsequently direct the SAM to generate pixel-level\nrefined masks, thereby completing the semantic transmission pipeline. Extensive\nexperiments (RefSegRS, RRSIS-D, and RISBench) demonstrate that RSRefSeg 2\nsurpasses contemporary methods in segmentation accuracy (+~3% gIoU) and complex\nsemantic interpretation. Code is available at:\nhttps://github.com/KyanChen/RSRefSeg2.",
      "url": "http://arxiv.org/abs/2507.06231v1",
      "published_time_eastern_timestamp": 1751997598.0
    },
    {
      "title": "Error Exponents for Quantum Packing Problems via An Operator Layer Cake\n  Theorem",
      "summary": "In this work, we prove a one-shot random coding bound for classical-quantum\nchannel coding, a problem conjectured by Burnashev and Holevo in 1998. By\nchoosing the optimal input distribution, we recover the optimal error exponent\n(i.e., the reliability function) of classical-quantum channels for rates above\nthe critical rate. Our result extends to various quantum packing-type problems,\nincluding classical communication over any fully quantum channel with or\nwithout entanglement-assistance, constant composition codes, and classical data\ncompression with quantum side information via fixed-length or variable-length\ncoding.\n  Our technical ingredient is to establish an operator layer cake theorem - the\ndirectional derivative of an operator logarithm admits an integral\nrepresentation of certain projections. This shows that a kind of pretty-good\nmeasurement is equivalent to a randomized Holevo-Helstrom measurement, which\nprovides an operational explanation of why the pretty-good measurement is\npretty good.",
      "url": "http://arxiv.org/abs/2507.06232v1",
      "published_time_eastern_timestamp": 1751997598.0
    },
    {
      "title": "Feed-Forward SceneDINO for Unsupervised Semantic Scene Completion",
      "summary": "Semantic scene completion (SSC) aims to infer both the 3D geometry and\nsemantics of a scene from single images. In contrast to prior work on SSC that\nheavily relies on expensive ground-truth annotations, we approach SSC in an\nunsupervised setting. Our novel method, SceneDINO, adapts techniques from\nself-supervised representation learning and 2D unsupervised scene understanding\nto SSC. Our training exclusively utilizes multi-view consistency\nself-supervision without any form of semantic or geometric ground truth. Given\na single input image, SceneDINO infers the 3D geometry and expressive 3D DINO\nfeatures in a feed-forward manner. Through a novel 3D feature distillation\napproach, we obtain unsupervised 3D semantics. In both 3D and 2D unsupervised\nscene understanding, SceneDINO reaches state-of-the-art segmentation accuracy.\nLinear probing our 3D features matches the segmentation accuracy of a current\nsupervised SSC approach. Additionally, we showcase the domain generalization\nand multi-view consistency of SceneDINO, taking the first steps towards a\nstrong foundation for single image 3D scene understanding.",
      "url": "http://arxiv.org/abs/2507.06230v1",
      "published_time_eastern_timestamp": 1751997590.0
    },
    {
      "title": "Agent KB: Leveraging Cross-Domain Experience for Agentic Problem Solving",
      "summary": "As language agents tackle increasingly complex tasks, they struggle with\neffective error correction and experience reuse across domains. We introduce\nAgent KB, a hierarchical experience framework that enables complex agentic\nproblem solving via a novel Reason-Retrieve-Refine pipeline. Agent KB addresses\na core limitation: agents traditionally cannot learn from each other's\nexperiences. By capturing both high-level strategies and detailed execution\nlogs, Agent KB creates a shared knowledge base that enables cross-agent\nknowledge transfer. Evaluated on the GAIA benchmark, Agent KB improves success\nrates by up to 16.28 percentage points. On the most challenging tasks, Claude-3\nimproves from 38.46% to 57.69%, while GPT-4 improves from 53.49% to 73.26% on\nintermediate tasks. On SWE-bench code repair, Agent KB enables Claude-3 to\nimprove from 41.33% to 53.33%. Our results suggest that Agent KB provides a\nmodular, framework-agnostic infrastructure for enabling agents to learn from\npast experiences and generalize successful strategies to new tasks.",
      "url": "http://arxiv.org/abs/2507.06229v1",
      "published_time_eastern_timestamp": 1751997562.0
    },
    {
      "title": "Is Diversity All You Need for Scalable Robotic Manipulation?",
      "summary": "Data scaling has driven remarkable success in foundation models for Natural\nLanguage Processing (NLP) and Computer Vision (CV), yet the principles of\neffective data scaling in robotic manipulation remain insufficiently\nunderstood. In this work, we investigate the nuanced role of data diversity in\nrobot learning by examining three critical dimensions-task (what to do),\nembodiment (which robot to use), and expert (who demonstrates)-challenging the\nconventional intuition of \"more diverse is better\". Throughout extensive\nexperiments on various robot platforms, we reveal that (1) task diversity\nproves more critical than per-task demonstration quantity, benefiting transfer\nfrom diverse pre-training tasks to novel downstream scenarios; (2)\nmulti-embodiment pre-training data is optional for cross-embodiment\ntransfer-models trained on high-quality single-embodiment data can efficiently\ntransfer to different platforms, showing more desirable scaling property during\nfine-tuning than multi-embodiment pre-trained models; and (3) expert diversity,\narising from individual operational preferences and stochastic variations in\nhuman demonstrations, can be confounding to policy learning, with velocity\nmultimodality emerging as a key contributing factor. Based on this insight, we\npropose a distribution debiasing method to mitigate velocity ambiguity, the\nyielding GO-1-Pro achieves substantial performance gains of 15%, equivalent to\nusing 2.5 times pre-training data. Collectively, these findings provide new\nperspectives and offer practical guidance on how to scale robotic manipulation\ndatasets effectively.",
      "url": "http://arxiv.org/abs/2507.06219v1",
      "published_time_eastern_timestamp": 1751997164.0
    },
    {
      "title": "Modern Methods in Associative Memory",
      "summary": "Associative Memories like the famous Hopfield Networks are elegant models for\ndescribing fully recurrent neural networks whose fundamental job is to store\nand retrieve information. In the past few years they experienced a surge of\ninterest due to novel theoretical results pertaining to their information\nstorage capabilities, and their relationship with SOTA AI architectures, such\nas Transformers and Diffusion Models. These connections open up possibilities\nfor interpreting the computation of traditional AI networks through the\ntheoretical lens of Associative Memories. Additionally, novel Lagrangian\nformulations of these networks make it possible to design powerful distributed\nmodels that learn useful representations and inform the design of novel\narchitectures. This tutorial provides an approachable introduction to\nAssociative Memories, emphasizing the modern language and methods used in this\narea of research, with practical hands-on mathematical derivations and coding\nnotebooks.",
      "url": "http://arxiv.org/abs/2507.06211v1",
      "published_time_eastern_timestamp": 1751996439.0
    },
    {
      "title": "DS@GT at CheckThat! 2025: Ensemble Methods for Detection of Scientific\n  Discourse on Social Media",
      "summary": "In this paper, we, as the DS@GT team for CLEF 2025 CheckThat! Task 4a\nScientific Web Discourse Detection, present the methods we explored for this\ntask. For this multiclass classification task, we determined if a tweet\ncontained a scientific claim, a reference to a scientific study or publication,\nand/or mentions of scientific entities, such as a university or a scientist. We\npresent 3 modeling approaches for this task: transformer finetuning, few-shot\nprompting of LLMs, and a combined ensemble model whose design was informed by\nearlier experiments. Our team placed 7th in the competition, achieving a\nmacro-averaged F1 score of 0.8611, an improvement over the DeBERTaV3 baseline\nof 0.8375. Our code is available on Github at\nhttps://github.com/dsgt-arc/checkthat-2025-swd/tree/main/subtask-4a.",
      "url": "http://arxiv.org/abs/2507.06205v1",
      "published_time_eastern_timestamp": 1751995818.0
    },
    {
      "title": "Differential Mamba",
      "summary": "Sequence models like Transformers and RNNs often overallocate attention to\nirrelevant context, leading to noisy intermediate representations. This\ndegrades LLM capabilities by promoting hallucinations, weakening long-range and\nretrieval abilities, and reducing robustness. Recent work has shown that\ndifferential design can mitigate this issue in Transformers, improving their\neffectiveness across various applications. In this paper, we explore whether\nthese techniques, originally developed for Transformers, can be applied to\nMamba, a recent architecture based on selective state-space layers that\nachieves Transformer-level performance with greater efficiency. We show that a\nnaive adaptation of differential design to Mamba is insufficient and requires\ncareful architectural modifications. To address this, we introduce a novel\ndifferential mechanism for Mamba, empirically validated on language modeling\nbenchmarks, demonstrating improved retrieval capabilities and superior\nperformance over vanilla Mamba. Finally, we conduct extensive ablation studies\nand empirical analyses to justify our design choices and provide evidence that\nour approach effectively mitigates the overallocation problem in Mamba-based\nmodels. Our code is publicly available.",
      "url": "http://arxiv.org/abs/2507.06204v1",
      "published_time_eastern_timestamp": 1751995814.0
    },
    {
      "title": "Surface-Code Hardware Hamiltonian",
      "summary": "We present a scalable framework for accurately modeling many-body\ninteractions in surface-code quantum processor units (QPUs). Combining a\nconcise diagrammatic formalism with high-precision numerical methods, our\napproach efficiently evaluates high-order, long-range Pauli string couplings\nand maps complete chip layouts onto exact effective Hamiltonians. Applying this\nmethod to surface-code architectures, such as Google's Sycamore lattice, we\nidentify three distinct operational regimes: computationally stable,\nerror-dominated, and hierarchy-inverted. Our analysis reveals that even modest\nincreases in residual qubit-qubit crosstalk can invert the interaction\nhierarchy, driving the system from a computationally favorable phase into a\ntopologically ordered regime. This framework thus serves as a powerful guide\nfor optimizing next-generation high-fidelity surface-code hardware and provides\na pathway to investigate emergent quantum many-body phenomena.",
      "url": "http://arxiv.org/abs/2507.06201v1",
      "published_time_eastern_timestamp": 1751995652.0
    },
    {
      "title": "DS@GT at CheckThat! 2025: Evaluating Context and Tokenization Strategies\n  for Numerical Fact Verification",
      "summary": "Numerical claims, statements involving quantities, comparisons, and temporal\nreferences, pose unique challenges for automated fact-checking systems. In this\nstudy, we evaluate modeling strategies for veracity prediction of such claims\nusing the QuanTemp dataset and building our own evidence retrieval pipeline. We\ninvestigate three key factors: (1) the impact of more evidences with longer\ninput context windows using ModernBERT, (2) the effect of right-to-left (R2L)\ntokenization, and (3) their combined influence on classification performance.\nContrary to prior findings in arithmetic reasoning tasks, R2L tokenization does\nnot boost natural language inference (NLI) of numerical tasks. A longer context\nwindow does also not enhance veracity performance either, highlighting evidence\nquality as the dominant bottleneck. Our best-performing system achieves\ncompetitive macro-average F1 score of 0.57 and places us among the Top-4\nsubmissions in Task 3 of CheckThat! 2025. Our code is available at\nhttps://github.com/dsgt-arc/checkthat-2025-numerical.",
      "url": "http://arxiv.org/abs/2507.06195v1",
      "published_time_eastern_timestamp": 1751995342.0
    },
    {
      "title": "DS@GT at CheckThat! 2025: Detecting Subjectivity via Transfer-Learning\n  and Corrective Data Augmentation",
      "summary": "This paper presents our submission to Task 1, Subjectivity Detection, of the\nCheckThat! Lab at CLEF 2025. We investigate the effectiveness of\ntransfer-learning and stylistic data augmentation to improve classification of\nsubjective and objective sentences in English news text. Our approach contrasts\nfine-tuning of pre-trained encoders and transfer-learning of fine-tuned\ntransformer on related tasks. We also introduce a controlled augmentation\npipeline using GPT-4o to generate paraphrases in predefined subjectivity\nstyles. To ensure label and style consistency, we employ the same model to\ncorrect and refine the generated samples. Results show that transfer-learning\nof specified encoders outperforms fine-tuning general-purpose ones, and that\ncarefully curated augmentation significantly enhances model robustness,\nespecially in detecting subjective content. Our official submission placed us\n$16^{th}$ of 24 participants. Overall, our findings underscore the value of\ncombining encoder specialization with label-consistent augmentation for\nimproved subjectivity detection. Our code is available at\nhttps://github.com/dsgt-arc/checkthat-2025-subject.",
      "url": "http://arxiv.org/abs/2507.06189v1",
      "published_time_eastern_timestamp": 1751995130.0
    },
    {
      "title": "CriticLean: Critic-Guided Reinforcement Learning for Mathematical\n  Formalization",
      "summary": "Translating natural language mathematical statements into formal, executable\ncode is a fundamental challenge in automated theorem proving. While prior work\nhas focused on generation and compilation success, little attention has been\npaid to the critic phase-the evaluation of whether generated formalizations\ntruly capture the semantic intent of the original problem. In this paper, we\nintroduce CriticLean, a novel critic-guided reinforcement learning framework\nthat elevates the role of the critic from a passive validator to an active\nlearning component. Specifically, first, we propose the CriticLeanGPT, trained\nvia supervised fine-tuning and reinforcement learning, to rigorously assess the\nsemantic fidelity of Lean 4 formalizations. Then, we introduce CriticLeanBench,\na benchmark designed to measure models' ability to distinguish semantically\ncorrect from incorrect formalizations, and demonstrate that our trained\nCriticLeanGPT models can significantly outperform strong open- and\nclosed-source baselines. Building on the CriticLean framework, we construct\nFineLeanCorpus, a dataset comprising over 285K problems that exhibits rich\ndomain diversity, broad difficulty coverage, and high correctness based on\nhuman evaluation. Overall, our findings highlight that optimizing the critic\nphase is essential for producing reliable formalizations, and we hope our\nCriticLean will provide valuable insights for future advances in formal\nmathematical reasoning.",
      "url": "http://arxiv.org/abs/2507.06181v1",
      "published_time_eastern_timestamp": 1751994219.0
    },
    {
      "title": "Hedge Funds on a Swamp: Analyzing Patterns, Vulnerabilities, and Defense\n  Measures in Blockchain Bridges [Experiment, Analysis \\& Benchmark]",
      "summary": "Blockchain bridges have become essential infrastructure for enabling\ninteroperability across different blockchain networks, with more than $24B\nmonthly bridge transaction volume. However, their growing adoption has been\naccompanied by a disproportionate rise in security breaches, making them the\nsingle largest source of financial loss in Web3. For cross-chain ecosystems to\nbe robust and sustainable, it is essential to understand and address these\nvulnerabilities. In this study, we present a comprehensive systematization of\nblockchain bridge design and security. We define three bridge security priors,\nformalize the architectural structure of 13 prominent bridges, and identify 23\nattack vectors grounded in real-world blockchain exploits. Using this\nfoundation, we evaluate 43 representative attack scenarios and introduce a\nlayered threat model that captures security failures across source chain,\noff-chain, and destination chain components.\n  Our analysis at the static code and transaction network levels reveals\nrecurring design flaws, particularly in access control, validator trust\nassumptions, and verification logic, and identifies key patterns in adversarial\nbehavior based on transaction-level traces. To support future development, we\npropose a decision framework for bridge architecture design, along with defense\nmechanisms such as layered validation and circuit breakers. This work provides\na data-driven foundation for evaluating bridge security and lays the groundwork\nfor standardizing resilient cross-chain infrastructure.",
      "url": "http://arxiv.org/abs/2507.06156v1",
      "published_time_eastern_timestamp": 1751992763.0
    },
    {
      "title": "Prompt-Free Conditional Diffusion for Multi-object Image Augmentation",
      "summary": "Diffusion models has underpinned much recent advances of dataset augmentation\nin various computer vision tasks. However, when involving generating\nmulti-object images as real scenarios, most existing methods either rely\nentirely on text condition, resulting in a deviation between the generated\nobjects and the original data, or rely too much on the original images,\nresulting in a lack of diversity in the generated images, which is of limited\nhelp to downstream tasks. To mitigate both problems with one stone, we propose\na prompt-free conditional diffusion framework for multi-object image\naugmentation. Specifically, we introduce a local-global semantic fusion\nstrategy to extract semantics from images to replace text, and inject knowledge\ninto the diffusion model through LoRA to alleviate the category deviation\nbetween the original model and the target dataset. In addition, we design a\nreward model based counting loss to assist the traditional reconstruction loss\nfor model training. By constraining the object counts of each category instead\nof pixel-by-pixel constraints, bridging the quantity deviation between the\ngenerated data and the original data while improving the diversity of the\ngenerated data. Experimental results demonstrate the superiority of the\nproposed method over several representative state-of-the-art baselines and\nshowcase strong downstream task gain and out-of-domain generalization\ncapabilities. Code is available at\n\\href{https://github.com/00why00/PFCD}{here}.",
      "url": "http://arxiv.org/abs/2507.06146v1",
      "published_time_eastern_timestamp": 1751992068.0
    },
    {
      "title": "LangMamba: A Language-driven Mamba Framework for Low-dose CT Denoising\n  with Vision-language Models",
      "summary": "Low-dose computed tomography (LDCT) reduces radiation exposure but often\ndegrades image quality, potentially compromising diagnostic accuracy. Existing\ndeep learning-based denoising methods focus primarily on pixel-level mappings,\noverlooking the potential benefits of high-level semantic guidance. Recent\nadvances in vision-language models (VLMs) suggest that language can serve as a\npowerful tool for capturing structured semantic information, offering new\nopportunities to improve LDCT reconstruction. In this paper, we introduce\nLangMamba, a Language-driven Mamba framework for LDCT denoising that leverages\nVLM-derived representations to enhance supervision from normal-dose CT (NDCT).\nLangMamba follows a two-stage learning strategy. First, we pre-train a\nLanguage-guided AutoEncoder (LangAE) that leverages frozen VLMs to map NDCT\nimages into a semantic space enriched with anatomical information. Second, we\nsynergize LangAE with two key components to guide LDCT denoising:\nSemantic-Enhanced Efficient Denoiser (SEED), which enhances NDCT-relevant local\nsemantic while capturing global features with efficient Mamba mechanism, and\nLanguage-engaged Dual-space Alignment (LangDA) Loss, which ensures that\ndenoised images align with NDCT in both perceptual and semantic spaces.\nExtensive experiments on two public datasets demonstrate that LangMamba\noutperforms conventional state-of-the-art methods, significantly improving\ndetail preservation and visual fidelity. Remarkably, LangAE exhibits strong\ngeneralizability to unseen datasets, thereby reducing training costs.\nFurthermore, LangDA loss improves explainability by integrating language-guided\ninsights into image reconstruction and offers a plug-and-play fashion. Our\nfindings shed new light on the potential of language as a supervisory signal to\nadvance LDCT denoising. The code is publicly available on\nhttps://github.com/hao1635/LangMamba.",
      "url": "http://arxiv.org/abs/2507.06140v1",
      "published_time_eastern_timestamp": 1751991725.0
    },
    {
      "title": "Coding Triangle: How Does Large Language Model Understand Code?",
      "summary": "Large language models (LLMs) have achieved remarkable progress in code\ngeneration, yet their true programming competence remains underexplored. We\nintroduce the Code Triangle framework, which systematically evaluates LLMs\nacross three fundamental dimensions: editorial analysis, code implementation,\nand test case generation. Through extensive experiments on competitive\nprogramming benchmarks, we reveal that while LLMs can form a self-consistent\nsystem across these dimensions, their solutions often lack the diversity and\nrobustness of human programmers. We identify a significant distribution shift\nbetween model cognition and human expertise, with model errors tending to\ncluster due to training data biases and limited reasoning transfer. Our study\ndemonstrates that incorporating human-generated editorials, solutions, and\ndiverse test cases, as well as leveraging model mixtures, can substantially\nenhance both the performance and robustness of LLMs. Furthermore, we reveal\nboth the consistency and inconsistency in the cognition of LLMs that may\nfacilitate self-reflection and self-improvement, providing a potential\ndirection for developing more powerful coding models.",
      "url": "http://arxiv.org/abs/2507.06138v1",
      "published_time_eastern_timestamp": 1751991643.0
    },
    {
      "title": "NeoBabel: A Multilingual Open Tower for Visual Generation",
      "summary": "Text-to-image generation advancements have been predominantly\nEnglish-centric, creating barriers for non-English speakers and perpetuating\ndigital inequities. While existing systems rely on translation pipelines, these\nintroduce semantic drift, computational overhead, and cultural misalignment. We\nintroduce NeoBabel, a novel multilingual image generation framework that sets a\nnew Pareto frontier in performance, efficiency and inclusivity, supporting six\nlanguages: English, Chinese, Dutch, French, Hindi, and Persian. The model is\ntrained using a combination of large-scale multilingual pretraining and\nhigh-resolution instruction tuning. To evaluate its capabilities, we expand two\nEnglish-only benchmarks to multilingual equivalents: m-GenEval and m-DPG.\nNeoBabel achieves state-of-the-art multilingual performance while retaining\nstrong English capability, scoring 0.75 on m-GenEval and 0.68 on m-DPG.\nNotably, it performs on par with leading models on English tasks while\noutperforming them by +0.11 and +0.09 on multilingual benchmarks, even though\nthese models are built on multilingual base LLMs. This demonstrates the\neffectiveness of our targeted alignment training for preserving and extending\ncrosslingual generalization. We further introduce two new metrics to rigorously\nassess multilingual alignment and robustness to code-mixed prompts. Notably,\nNeoBabel matches or exceeds English-only models while being 2-4x smaller. We\nrelease an open toolkit, including all code, model checkpoints, a curated\ndataset of 124M multilingual text-image pairs, and standardized multilingual\nevaluation protocols, to advance inclusive AI research. Our work demonstrates\nthat multilingual capability is not a trade-off but a catalyst for improved\nrobustness, efficiency, and cultural fidelity in generative AI.",
      "url": "http://arxiv.org/abs/2507.06137v1",
      "published_time_eastern_timestamp": 1751991585.0
    },
    {
      "title": "OpenAgentSafety: A Comprehensive Framework for Evaluating Real-World AI\n  Agent Safety",
      "summary": "Recent advances in AI agents capable of solving complex, everyday tasks, from\nscheduling to customer service, have enabled deployment in real-world settings,\nbut their possibilities for unsafe behavior demands rigorous evaluation. While\nprior benchmarks have attempted to assess agent safety, most fall short by\nrelying on simulated environments, narrow task domains, or unrealistic tool\nabstractions. We introduce OpenAgentSafety, a comprehensive and modular\nframework for evaluating agent behavior across eight critical risk categories.\nUnlike prior work, our framework evaluates agents that interact with real\ntools, including web browsers, code execution environments, file systems, bash\nshells, and messaging platforms; and supports over 350 multi-turn, multi-user\ntasks spanning both benign and adversarial user intents. OpenAgentSafety is\ndesigned for extensibility, allowing researchers to add tools, tasks, websites,\nand adversarial strategies with minimal effort. It combines rule-based analysis\nwith LLM-as-judge assessments to detect both overt and subtle unsafe behaviors.\nEmpirical analysis of five prominent LLMs in agentic scenarios reveals unsafe\nbehavior in 51.2% of safety-vulnerable tasks with Claude-Sonnet-3.7, to 72.7%\nwith o3-mini, highlighting critical safety vulnerabilities and the need for\nstronger safeguards before real-world deployment.",
      "url": "http://arxiv.org/abs/2507.06134v1",
      "published_time_eastern_timestamp": 1751991534.0
    },
    {
      "title": "Unconditional Diffusion for Generative Sequential Recommendation",
      "summary": "Diffusion models, known for their generative ability to simulate data\ncreation through noise-adding and denoising processes, have emerged as a\npromising approach for building generative recommenders. To incorporate user\nhistory for personalization, existing methods typically adopt a conditional\ndiffusion framework, where the reverse denoising process of reconstructing\nitems from noise is modified to be conditioned on the user history. However,\nthis design may fail to fully utilize historical information, as it gets\ndistracted by the need to model the \"item $\\leftrightarrow$ noise\" translation.\nThis motivates us to reformulate the diffusion process for sequential\nrecommendation in an unconditional manner, treating user history (instead of\nnoise) as the endpoint of the forward diffusion process (i.e., the starting\npoint of the reverse process), rather than as a conditional input. This\nformulation allows for exclusive focus on modeling the \"item $\\leftrightarrow$\nhistory\" translation. To this end, we introduce Brownian Bridge Diffusion\nRecommendation (BBDRec). By leveraging a Brownian bridge process, BBDRec\nenforces a structured noise addition and denoising mechanism, ensuring that the\ntrajectories are constrained towards a specific endpoint -- user history,\nrather than noise. Extensive experiments demonstrate BBDRec's effectiveness in\nenhancing sequential recommendation performance. The source code is available\nat https://github.com/baiyimeng/BBDRec.",
      "url": "http://arxiv.org/abs/2507.06121v1",
      "published_time_eastern_timestamp": 1751990718.0
    },
    {
      "title": "Fun with flags: How Compilers Break and Fix Constant-Time Code",
      "summary": "Developers rely on constant-time programming to prevent timing side-channel\nattacks. But these efforts can be undone by compilers, whose optimizations may\nsilently reintroduce leaks. While recent works have measured the extent of such\nleakage, they leave developers without actionable insights: which optimization\npasses are responsible, and how to disable them without modifying the compiler\nremains unclear.\n  In this paper, we conduct a qualitative analysis of how compiler\noptimizations break constant-time code. We construct a dataset of\ncompiler-introduced constant-time violations and analyze the internals of two\nwidely used compilers, GCC and LLVM, to identify the specific optimization\npasses responsible. Our key insight is that a small set of passes are at the\nroot of most leaks. To the best of our knowledge, we are also the first to\ncharacterize how the interactions between these passes contribute to leakage.\nBased on this analysis, we propose an original and practical mitigation that\nrequires no source code modification or custom compiler: disabling selected\noptimization passes via compiler flags. We show that this approach\nsignificantly reduces leakage with minimal performance overhead, offering an\nimmediately deployable defense for developers.",
      "url": "http://arxiv.org/abs/2507.06112v1",
      "published_time_eastern_timestamp": 1751989937.0
    }
  ]
}