{
  "last_updated": "2025-09-22T14:16:47.599866-04:00",
  "papers": [
    {
      "title": "Inverting Trojans in LLMs",
      "summary": "While effective backdoor detection and inversion schemes have been developed\nfor AIs used e.g. for images, there are challenges in \"porting\" these methods\nto LLMs. First, the LLM input space is discrete, which precludes gradient-based\nsearch over this space, central to many backdoor inversion methods. Second,\nthere are ~30,000^k k-tuples to consider, k the token-length of a putative\ntrigger. Third, for LLMs there is the need to blacklist tokens that have strong\nmarginal associations with the putative target response (class) of an attack,\nas such tokens give false detection signals. However, good blacklists may not\nexist for some domains. We propose a LLM trigger inversion approach with three\nkey components: i) discrete search, with putative triggers greedily accreted,\nstarting from a select list of singletons; ii) implicit blacklisting, achieved\nby evaluating the average cosine similarity, in activation space, between a\ncandidate trigger and a small clean set of samples from the putative target\nclass; iii) detection when a candidate trigger elicits high misclassifications,\nand with unusually high decision confidence. Unlike many recent works, we\ndemonstrate that our approach reliably detects and successfully inverts\nground-truth backdoor trigger phrases.",
      "url": "http://arxiv.org/abs/2509.16203v1",
      "published_time_eastern_timestamp": 1758304797.0
    },
    {
      "title": "RPG: A Repository Planning Graph for Unified and Scalable Codebase\n  Generation",
      "summary": "Large language models excel at function- and file-level code generation, yet\ngenerating complete repositories from scratch remains a fundamental challenge.\nThis process demands coherent and reliable planning across proposal- and\nimplementation-level stages, while natural language, due to its ambiguity and\nverbosity, is ill-suited for faithfully representing complex software\nstructures. To address this, we introduce the Repository Planning Graph (RPG),\na persistent representation that unifies proposal- and implementation-level\nplanning by encoding capabilities, file structures, data flows, and functions\nin one graph. RPG replaces ambiguous natural language with an explicit\nblueprint, enabling long-horizon planning and scalable repository generation.\nBuilding on RPG, we develop ZeroRepo, a graph-driven framework for repository\ngeneration from scratch. It operates in three stages: proposal-level planning\nand implementation-level refinement to construct the graph, followed by\ngraph-guided code generation with test validation. To evaluate this setting, we\nconstruct RepoCraft, a benchmark of six real-world projects with 1,052 tasks.\nOn RepoCraft, ZeroRepo produces repositories averaging nearly 36K LOC, roughly\n3.9$\\times$ the strongest baseline (Claude Code) and about 64$\\times$ other\nbaselines. It attains 81.5% functional coverage and a 69.7% pass rate,\nexceeding Claude Code by 27.3 and 35.8 percentage points, respectively. Further\nanalysis shows that RPG models complex dependencies, enables progressively more\nsophisticated planning through near-linear scaling, and enhances LLM\nunderstanding of repositories, thereby accelerating agent localization.",
      "url": "http://arxiv.org/abs/2509.16198v1",
      "published_time_eastern_timestamp": 1758304694.0
    },
    {
      "title": "MANZANO: A Simple and Scalable Unified Multimodal Model with a Hybrid\n  Vision Tokenizer",
      "summary": "Unified multimodal Large Language Models (LLMs) that can both understand and\ngenerate visual content hold immense potential. However, existing open-source\nmodels often suffer from a performance trade-off between these capabilities. We\npresent Manzano, a simple and scalable unified framework that substantially\nreduces this tension by coupling a hybrid image tokenizer with a well-curated\ntraining recipe. A single shared vision encoder feeds two lightweight adapters\nthat produce continuous embeddings for image-to-text understanding and discrete\ntokens for text-to-image generation within a common semantic space. A unified\nautoregressive LLM predicts high-level semantics in the form of text and image\ntokens, with an auxiliary diffusion decoder subsequently translating the image\ntokens into pixels. The architecture, together with a unified training recipe\nover understanding and generation data, enables scalable joint learning of both\ncapabilities. Manzano achieves state-of-the-art results among unified models,\nand is competitive with specialist models, particularly on text-rich\nevaluation. Our studies show minimal task conflicts and consistent gains from\nscaling model size, validating our design choice of a hybrid tokenizer.",
      "url": "http://arxiv.org/abs/2509.16197v1",
      "published_time_eastern_timestamp": 1758304680.0
    },
    {
      "title": "CultureScope: A Dimensional Lens for Probing Cultural Understanding in\n  LLMs",
      "summary": "As large language models (LLMs) are increasingly deployed in diverse cultural\nenvironments, evaluating their cultural understanding capability has become\nessential for ensuring trustworthy and culturally aligned applications.\nHowever, most existing benchmarks lack comprehensiveness and are challenging to\nscale and adapt across different cultural contexts, because their frameworks\noften lack guidance from well-established cultural theories and tend to rely on\nexpert-driven manual annotations. To address these issues, we propose\nCultureScope, the most comprehensive evaluation framework to date for assessing\ncultural understanding in LLMs. Inspired by the cultural iceberg theory, we\ndesign a novel dimensional schema for cultural knowledge classification,\ncomprising 3 layers and 140 dimensions, which guides the automated construction\nof culture-specific knowledge bases and corresponding evaluation datasets for\nany given languages and cultures. Experimental results demonstrate that our\nmethod can effectively evaluate cultural understanding. They also reveal that\nexisting large language models lack comprehensive cultural competence, and\nmerely incorporating multilingual data does not necessarily enhance cultural\nunderstanding. All code and data files are available at\nhttps://github.com/HoganZinger/Culture",
      "url": "http://arxiv.org/abs/2509.16188v1",
      "published_time_eastern_timestamp": 1758304068.0
    },
    {
      "title": "MatchFixAgent: Language-Agnostic Autonomous Repository-Level Code\n  Translation Validation and Repair",
      "summary": "Code translation transforms source code from one programming language (PL) to\nanother. Validating the functional equivalence of translation and repairing, if\nnecessary, are critical steps in code translation. Existing automated\nvalidation and repair approaches struggle to generalize to many PLs due to high\nengineering overhead, and they rely on existing and often inadequate test\nsuites, which results in false claims of equivalence and ineffective\ntranslation repair. We develop MatchFixAgent, a large language model\n(LLM)-based, PL-agnostic framework for equivalence validation and repair of\ntranslations. MatchFixAgent features a multi-agent architecture that divides\nequivalence validation into several sub-tasks to ensure thorough and consistent\nsemantic analysis of the translation. Then it feeds this analysis to test agent\nto write and execute tests. Upon observing a test failure, the repair agent\nattempts to fix the translation bug. The final (in)equivalence decision is made\nby the verdict agent, considering semantic analyses and test execution results.\n  We compare MatchFixAgent's validation and repair results with four\nrepository-level code translation techniques. We use 2,219 translation pairs\nfrom their artifacts, which cover 6 PL pairs, and are collected from 24 GitHub\nprojects totaling over 900K lines of code. Our results demonstrate that\nMatchFixAgent produces (in)equivalence verdicts for 99.2% of translation pairs,\nwith the same equivalence validation result as prior work on 72.8% of them.\nWhen MatchFixAgent's result disagrees with prior work, we find that 60.7% of\nthe time MatchFixAgent's result is actually correct. In addition, we show that\nMatchFixAgent can repair 50.6% of inequivalent translation, compared to prior\nwork's 18.5%. This demonstrates that MatchFixAgent is far more adaptable to\nmany PL pairs than prior work, while producing highly accurate validation\nresults.",
      "url": "http://arxiv.org/abs/2509.16187v1",
      "published_time_eastern_timestamp": 1758303973.0
    },
    {
      "title": "Agentic Aerial Cinematography: From Dialogue Cues to Cinematic\n  Trajectories",
      "summary": "We present Agentic Aerial Cinematography: From Dialogue Cues to Cinematic\nTrajectories (ACDC), an autonomous drone cinematography system driven by\nnatural language communication between human directors and drones. The main\nlimitation of previous drone cinematography workflows is that they require\nmanual selection of waypoints and view angles based on predefined human intent,\nwhich is labor-intensive and yields inconsistent performance. In this paper, we\npropose employing large language models (LLMs) and vision foundation models\n(VFMs) to convert free-form natural language prompts directly into executable\nindoor UAV video tours. Specifically, our method comprises a vision-language\nretrieval pipeline for initial waypoint selection, a preference-based Bayesian\noptimization framework that refines poses using aesthetic feedback, and a\nmotion planner that generates safe quadrotor trajectories. We validate ACDC\nthrough both simulation and hardware-in-the-loop experiments, demonstrating\nthat it robustly produces professional-quality footage across diverse indoor\nscenes without requiring expertise in robotics or cinematography. These results\nhighlight the potential of embodied AI agents to close the loop from\nopen-vocabulary dialogue to real-world autonomous aerial cinematography.",
      "url": "http://arxiv.org/abs/2509.16176v1",
      "published_time_eastern_timestamp": 1758303351.0
    },
    {
      "title": "Pointing to a Llama and Call it a Camel: On the Sycophancy of Multimodal\n  Large Language Models",
      "summary": "Multimodal large language models (MLLMs) have demonstrated extraordinary\ncapabilities in conducting conversations based on image inputs. However, we\nobserve that MLLMs exhibit a pronounced form of visual sycophantic behavior.\nWhile similar behavior has also been noted in text-based large language models\n(LLMs), it becomes significantly more prominent when MLLMs process image\ninputs. We refer to this phenomenon as the \"sycophantic modality gap.\" To\nbetter understand this issue, we further analyze the factors that contribute to\nthe exacerbation of this gap. To mitigate the visual sycophantic behavior, we\nfirst experiment with naive supervised fine-tuning to help the MLLM resist\nmisleading instructions from the user. However, we find that this approach also\nmakes the MLLM overly resistant to corrective instructions (i.e., stubborn even\nif it is wrong). To alleviate this trade-off, we propose Sycophantic Reflective\nTuning (SRT), which enables the MLLM to engage in reflective reasoning,\nallowing it to determine whether a user's instruction is misleading or\ncorrective before drawing a conclusion. After applying SRT, we observe a\nsignificant reduction in sycophantic behavior toward misleading instructions,\nwithout resulting in excessive stubbornness when receiving corrective\ninstructions.",
      "url": "http://arxiv.org/abs/2509.16149v1",
      "published_time_eastern_timestamp": 1758301040.0
    },
    {
      "title": "Reward Evolution with Graph-of-Thoughts: A Bi-Level Language Model\n  Framework for Reinforcement Learning",
      "summary": "Designing effective reward functions remains a major challenge in\nreinforcement learning (RL), often requiring considerable human expertise and\niterative refinement. Recent advances leverage Large Language Models (LLMs) for\nautomated reward design, but these approaches are limited by hallucinations,\nreliance on human feedback, and challenges with handling complex, multi-step\ntasks. In this work, we introduce Reward Evolution with Graph-of-Thoughts\n(RE-GoT), a novel bi-level framework that enhances LLMs with structured\ngraph-based reasoning and integrates Visual Language Models (VLMs) for\nautomated rollout evaluation. RE-GoT first decomposes tasks into\ntext-attributed graphs, enabling comprehensive analysis and reward function\ngeneration, and then iteratively refines rewards using visual feedback from\nVLMs without human intervention. Extensive experiments on 10 RoboGen and 4\nManiSkill2 tasks demonstrate that RE-GoT consistently outperforms existing\nLLM-based baselines. On RoboGen, our method improves average task success rates\nby 32.25%, with notable gains on complex multi-step tasks. On ManiSkill2,\nRE-GoT achieves an average success rate of 93.73% across four diverse\nmanipulation tasks, significantly surpassing prior LLM-based approaches and\neven exceeding expert-designed rewards. Our results indicate that combining\nLLMs and VLMs with graph-of-thoughts reasoning provides a scalable and\neffective solution for autonomous reward evolution in RL.",
      "url": "http://arxiv.org/abs/2509.16136v1",
      "published_time_eastern_timestamp": 1758299727.0
    },
    {
      "title": "AnchoredAI: Contextual Anchoring of AI Comments Improves Writer Agency\n  and Ownership",
      "summary": "Generative AI is increasingly integrated into writing support, yet current\nchat-based interfaces often obscure referential context and risk amplifying\nautomation bias and overreliance. We introduce AnchoredAI, a novel system that\nanchors AI feedback directly to relevant text spans. AnchoredAI implements two\nkey mechanisms: (1) an Anchoring Context Window (ACW) that maintains unique,\ncontext-rich references, and (2) an update-aware context retrieval method that\npreserves the intent of prior comments after document edits. In a controlled\nuser study, we compared AnchoredAI to a chat-based LLM interface. Results show\nthat AnchoredAI led to more targeted revisions while fostering a stronger\nagency metrics (e.g., control and ownership) among writers. These findings\nhighlight how interface design shapes AI-assisted writing, suggesting that\nanchoring can mitigate overreliance and enable more precise, user-driven\nrevision practices.",
      "url": "http://arxiv.org/abs/2509.16128v1",
      "published_time_eastern_timestamp": 1758299130.0
    },
    {
      "title": "CodeRAG: Finding Relevant and Necessary Knowledge for\n  Retrieval-Augmented Repository-Level Code Completion",
      "summary": "Repository-level code completion automatically predicts the unfinished code\nbased on the broader information from the repository. Recent strides in Code\nLarge Language Models (code LLMs) have spurred the development of\nrepository-level code completion methods, yielding promising results.\nNevertheless, they suffer from issues such as inappropriate query construction,\nsingle-path code retrieval, and misalignment between code retriever and code\nLLM. To address these problems, we introduce CodeRAG, a framework tailored to\nidentify relevant and necessary knowledge for retrieval-augmented\nrepository-level code completion. Its core components include log probability\nguided query construction, multi-path code retrieval, and preference-aligned\nBestFit reranking. Extensive experiments on benchmarks ReccEval and CCEval\ndemonstrate that CodeRAG significantly and consistently outperforms\nstate-of-the-art methods. The implementation of CodeRAG is available at\nhttps://github.com/KDEGroup/CodeRAG.",
      "url": "http://arxiv.org/abs/2509.16112v1",
      "published_time_eastern_timestamp": 1758297460.0
    }
  ]
}