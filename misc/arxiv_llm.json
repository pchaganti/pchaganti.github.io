{
  "last_updated": "2025-11-10T16:11:28.283577-05:00",
  "papers": [
    {
      "title": "SWE-Compass: Towards Unified Evaluation of Agentic Coding Abilities for\n  Large Language Models",
      "summary": "Evaluating large language models (LLMs) for software engineering has been\nlimited by narrow task coverage, language bias, and insufficient alignment with\nreal-world developer workflows. Existing benchmarks often focus on algorithmic\nproblems or Python-centric bug fixing, leaving critical dimensions of software\nengineering underexplored. To address these gaps, we introduce SWE-Compass1, a\ncomprehensive benchmark that unifies heterogeneous code-related evaluations\ninto a structured and production-aligned framework. SWE-Compass spans 8 task\ntypes, 8 programming scenarios, and 10 programming languages, with 2000\nhigh-quality instances curated from authentic GitHub pull requests and refined\nthrough systematic filtering and validation. We benchmark ten state-of-the-art\nLLMs under two agentic frameworks, SWE-Agent and Claude Code, revealing a clear\nhierarchy of difficulty across task types, languages, and scenarios. Moreover,\nby aligning evaluation with real-world developer practices, SWE-Compass\nprovides a rigorous and reproducible foundation for diagnosing and advancing\nagentic coding capabilities in large language models.",
      "url": "http://arxiv.org/abs/2511.05459v1",
      "published_time_eastern_timestamp": 1762538492.0
    },
    {
      "title": "Steering Language Models with Weight Arithmetic",
      "summary": "Providing high-quality feedback to Large Language Models (LLMs) on a diverse\ntraining distribution can be difficult and expensive, and providing feedback\nonly on a narrow distribution can result in unintended generalizations. To\nbetter leverage narrow training data, we propose contrastive weight steering, a\nsimple post-training method that edits the model parameters using weight\narithmetic. We isolate a behavior direction in weight-space by subtracting the\nweight deltas from two small fine-tunes -- one that induces the desired\nbehavior and another that induces its opposite -- and then add or remove this\ndirection to modify the model's weights. We apply this technique to mitigate\nsycophancy and induce misalignment, and find that weight steering often\ngeneralizes further than activation steering, achieving stronger\nout-of-distribution behavioral control before degrading general capabilities.\nWe also show that, in the context of task-specific fine-tuning, weight steering\ncan partially mitigate undesired behavioral drift: it can reduce sycophancy and\nunder-refusals introduced during fine-tuning while preserving task performance\ngains. Finally, we provide preliminary evidence that emergent misalignment can\nbe detected by measuring the similarity between fine-tuning updates and an\n\"evil\" weight direction, suggesting that it may be possible to monitor the\nevolution of weights during training and detect rare misaligned behaviors that\nnever manifest during training or evaluations.",
      "url": "http://arxiv.org/abs/2511.05408v1",
      "published_time_eastern_timestamp": 1762533256.0
    },
    {
      "title": "Large Language Models for Explainable Threat Intelligence",
      "summary": "As cyber threats continue to grow in complexity, traditional security\nmechanisms struggle to keep up. Large language models (LLMs) offer significant\npotential in cybersecurity due to their advanced capabilities in text\nprocessing and generation. This paper explores the use of LLMs with\nretrieval-augmented generation (RAG) to obtain threat intelligence by combining\nreal-time information retrieval with domain-specific data. The proposed system,\nRAGRecon, uses a LLM with RAG to answer questions about cybersecurity threats.\nMoreover, it makes this form of Artificial Intelligence (AI) explainable by\ngenerating and visually presenting to the user a knowledge graph for every\nreply. This increases the transparency and interpretability of the reasoning of\nthe model, allowing analysts to better understand the connections made by the\nsystem based on the context recovered by the RAG system. We evaluated RAGRecon\nexperimentally with two datasets and seven different LLMs and the responses\nmatched the reference responses more than 91% of the time for the best\ncombinations.",
      "url": "http://arxiv.org/abs/2511.05406v1",
      "published_time_eastern_timestamp": 1762533161.0
    },
    {
      "title": "TeaRAG: A Token-Efficient Agentic Retrieval-Augmented Generation\n  Framework",
      "summary": "Retrieval-Augmented Generation (RAG) utilizes external knowledge to augment\nLarge Language Models' (LLMs) reliability. For flexibility, agentic RAG employs\nautonomous, multi-round retrieval and reasoning to resolve queries. Although\nrecent agentic RAG has improved via reinforcement learning, they often incur\nsubstantial token overhead from search and reasoning processes. This trade-off\nprioritizes accuracy over efficiency. To address this issue, this work proposes\nTeaRAG, a token-efficient agentic RAG framework capable of compressing both\nretrieval content and reasoning steps. 1) First, the retrieved content is\ncompressed by augmenting chunk-based semantic retrieval with a graph retrieval\nusing concise triplets. A knowledge association graph is then built from\nsemantic similarity and co-occurrence. Finally, Personalized PageRank is\nleveraged to highlight key knowledge within this graph, reducing the number of\ntokens per retrieval. 2) Besides, to reduce reasoning steps, Iterative\nProcess-aware Direct Preference Optimization (IP-DPO) is proposed.\nSpecifically, our reward function evaluates the knowledge sufficiency by a\nknowledge matching mechanism, while penalizing excessive reasoning steps. This\ndesign can produce high-quality preference-pair datasets, supporting iterative\nDPO to improve reasoning conciseness. Across six datasets, TeaRAG improves the\naverage Exact Match by 4% and 2% while reducing output tokens by 61% and 59% on\nLlama3-8B-Instruct and Qwen2.5-14B-Instruct, respectively. Code is available at\nhttps://github.com/Applied-Machine-Learning-Lab/TeaRAG.",
      "url": "http://arxiv.org/abs/2511.05385v1",
      "published_time_eastern_timestamp": 1762531714.0
    },
    {
      "title": "Connectomics Informed by Large Language Models",
      "summary": "Tractography is a unique method for mapping white matter connections in the\nbrain, but tractography algorithms suffer from an inherent trade-off between\nsensitivity and specificity that limits accuracy. Incorporating prior knowledge\nof white matter anatomy is an effective strategy for improving accuracy and has\nbeen successful for reducing false positives and false negatives in\nbundle-mapping protocols. However, it is challenging to scale this approach for\nconnectomics due to the difficulty in synthesising information relating to many\nthousands of possible connections. In this work, we develop and evaluate a\npipeline using large language models (LLMs) to generate quantitative priors for\nconnectomics, based on their knowledge of neuroanatomy. We benchmark our\napproach against an evaluation set derived from a gold-standard tractography\natlas, identifying prompting techniques to elicit accurate connectivity\ninformation from the LLMs. We further identify strategies for incorporating\nexternal knowledge sources into the pipeline, which can provide grounding for\nthe LLM and improve accuracy. Finally, we demonstrate how the LLM-derived\npriors can augment existing tractography filtering approaches by identifying\ntrue-positive connections to retain during the filtering process. We show that\nthese additional connections can improve the accuracy of a connectome-based\nmodel of pathology spread, which provides supporting evidence that the\nconnections preserved by the LLM are valid.",
      "url": "http://arxiv.org/abs/2511.05383v1",
      "published_time_eastern_timestamp": 1762531521.0
    },
    {
      "title": "What Are the Facts? Automated Extraction of Court-Established Facts from\n  Criminal-Court Opinions",
      "summary": "Criminal justice administrative data contain only a limited amount of\ninformation about the committed offense. However, there is an unused source of\nextensive information in continental European courts' decisions: descriptions\nof criminal behaviors in verdicts by which offenders are found guilty. In this\npaper, we study the feasibility of extracting these descriptions from publicly\navailable court decisions from Slovakia. We use two different approaches for\nretrieval: regular expressions and large language models (LLMs). Our baseline\nwas a simple method employing regular expressions to identify typical words\noccurring before and after the description. The advanced regular expression\napproach further focused on \"sparing\" and its normalization (insertion of\nspaces between individual letters), typical for delineating the description.\nThe LLM approach involved prompting the Gemini Flash 2.0 model to extract the\ndescriptions using predefined instructions. Although the baseline identified\ndescriptions in only 40.5% of verdicts, both methods significantly outperformed\nit, achieving 97% with advanced regular expressions and 98.75% with LLMs, and\n99.5% when combined. Evaluation by law students showed that both advanced\nmethods matched human annotations in about 90% of cases, compared to just 34.5%\nfor the baseline. LLMs fully matched human-labeled descriptions in 91.75% of\ninstances, and a combination of advanced regular expressions with LLMs reached\n92%.",
      "url": "http://arxiv.org/abs/2511.05320v1",
      "published_time_eastern_timestamp": 1762528665.0
    },
    {
      "title": "$\\mathbf{S^2LM}$: Towards Semantic Steganography via Large Language\n  Models",
      "summary": "Although steganography has made significant advancements in recent years, it\nstill struggles to embed semantically rich, sentence-level information into\ncarriers. However, in the era of AIGC, the capacity of steganography is more\ncritical than ever. In this work, we present Sentence-to-Image Steganography,\nan instance of Semantic Steganography, a novel task that enables the hiding of\narbitrary sentence-level messages within a cover image. Furthermore, we\nestablish a benchmark named Invisible Text (IVT), comprising a diverse set of\nsentence-level texts as secret messages for evaluation. Finally, we present\n$\\mathbf{S^2LM}$: Semantic Steganographic Language Model, which utilizes large\nlanguage models (LLMs) to embed high-level textual information, such as\nsentences or even paragraphs, into images. Unlike traditional bit-level\ncounterparts, $\\mathrm{S^2LM}$ enables the integration of semantically rich\ncontent through a newly designed pipeline in which the LLM is involved\nthroughout the entire process. Both quantitative and qualitative experiments\ndemonstrate that our method effectively unlocks new semantic steganographic\ncapabilities for LLMs. The source code will be released soon.",
      "url": "http://arxiv.org/abs/2511.05319v1",
      "published_time_eastern_timestamp": 1762528660.0
    },
    {
      "title": "Cleaning Maintenance Logs with LLM Agents for Improved Predictive\n  Maintenance",
      "summary": "Economic constraints, limited availability of datasets for reproducibility\nand shortages of specialized expertise have long been recognized as key\nchallenges to the adoption and advancement of predictive maintenance (PdM) in\nthe automotive sector. Recent progress in large language models (LLMs) presents\nan opportunity to overcome these barriers and speed up the transition of PdM\nfrom research to industrial practice. Under these conditions, we explore the\npotential of LLM-based agents to support PdM cleaning pipelines. Specifically,\nwe focus on maintenance logs, a critical data source for training\nwell-performing machine learning (ML) models, but one often affected by errors\nsuch as typos, missing fields, near-duplicate entries, and incorrect dates. We\nevaluate LLM agents on cleaning tasks involving six distinct types of noise.\nOur findings show that LLMs are effective at handling generic cleaning tasks\nand offer a promising foundation for future industrial applications. While\ndomain-specific errors remain challenging, these results highlight the\npotential for further improvements through specialized training and enhanced\nagentic capabilities.",
      "url": "http://arxiv.org/abs/2511.05311v1",
      "published_time_eastern_timestamp": 1762528369.0
    },
    {
      "title": "Code Review Automation using Retrieval Augmented Generation",
      "summary": "Code review is essential for maintaining software quality but is\nlabor-intensive. Automated code review generation offers a promising solution\nto this challenge. Both deep learning-based generative techniques and\nretrieval-based methods have demonstrated strong performance in this task.\nHowever, despite these advancements, there are still some limitations where\ngenerated reviews can be either off-point or overly general. To address these\nissues, we introduce Retrieval-Augmented Reviewer (RARe), which leverages\nRetrieval-Augmented Generation (RAG) to combine retrieval-based and generative\nmethods, explicitly incorporating external domain knowledge into the code\nreview process. RARe uses a dense retriever to select the most relevant reviews\nfrom the codebase, which then enrich the input for a neural generator,\nutilizing the contextual learning capacity of large language models (LLMs), to\nproduce the final review. RARe outperforms state-of-the-art methods on two\nbenchmark datasets, achieving BLEU-4 scores of 12.32 and 12.96, respectively.\nIts effectiveness is further validated through a detailed human evaluation and\na case study using an interpretability tool, demonstrating its practical\nutility and reliability.",
      "url": "http://arxiv.org/abs/2511.05302v1",
      "published_time_eastern_timestamp": 1762527762.0
    },
    {
      "title": "QUESTER: Query Specification for Generative Retrieval",
      "summary": "Generative Retrieval (GR) differs from the traditional index-then-retrieve\npipeline by storing relevance in model parameters and directly generating\ndocument identifiers. However, GR often struggles to generalize and is costly\nto scale. We introduce QUESTER (QUEry SpecificaTion gEnerative Retrieval),\nwhich reframes GR as query specification generation - in this work, a simple\nkeyword query handled by BM25 - using a (small) LLM. The policy is trained\nusing reinforcement learning techniques (GRPO). Across in- and out-of-domain\nevaluations, we show that our model is more effective than BM25, and\ncompetitive with neural IR models, while maintaining a good efficiency",
      "url": "http://arxiv.org/abs/2511.05301v1",
      "published_time_eastern_timestamp": 1762527698.0
    },
    {
      "title": "LiveStar: Live Streaming Assistant for Real-World Online Video\n  Understanding",
      "summary": "Despite significant progress in Video Large Language Models (Video-LLMs) for\noffline video understanding, existing online Video-LLMs typically struggle to\nsimultaneously process continuous frame-by-frame inputs and determine optimal\nresponse timing, often compromising real-time responsiveness and narrative\ncoherence. To address these limitations, we introduce LiveStar, a pioneering\nlive streaming assistant that achieves always-on proactive responses through\nadaptive streaming decoding. Specifically, LiveStar incorporates: (1) a\ntraining strategy enabling incremental video-language alignment for\nvariable-length video streams, preserving temporal consistency across\ndynamically evolving frame sequences; (2) a response-silence decoding framework\nthat determines optimal proactive response timing via a single forward pass\nverification; (3) memory-aware acceleration via peak-end memory compression for\nonline inference on 10+ minute videos, combined with streaming key-value cache\nto achieve 1.53x faster inference. We also construct an OmniStar dataset, a\ncomprehensive dataset for training and benchmarking that encompasses 15 diverse\nreal-world scenarios and 5 evaluation tasks for online video understanding.\nExtensive experiments across three benchmarks demonstrate LiveStar's\nstate-of-the-art performance, achieving an average 19.5% improvement in\nsemantic correctness with 18.1% reduced timing difference compared to existing\nonline Video-LLMs, while improving FPS by 12.0% across all five OmniStar tasks.\nOur model and dataset can be accessed at https://github.com/yzy-bupt/LiveStar.",
      "url": "http://arxiv.org/abs/2511.05299v1",
      "published_time_eastern_timestamp": 1762527637.0
    },
    {
      "title": "Building Specialized Software-Assistant ChatBot with Graph-Based\n  Retrieval-Augmented Generation",
      "summary": "Digital Adoption Platforms (DAPs) have become essential tools for helping\nemployees navigate complex enterprise software such as CRM, ERP, or HRMS\nsystems. Companies like LemonLearning have shown how digital guidance can\nreduce training costs and accelerate onboarding. However, building and\nmaintaining these interactive guides still requires extensive manual effort.\nLeveraging Large Language Models as virtual assistants is an appealing\nalternative, yet without a structured understanding of the target software,\nLLMs often hallucinate and produce unreliable answers. Moreover, most\nproduction-grade LLMs are black-box APIs, making fine-tuning impractical due to\nthe lack of access to model weights. In this work, we introduce a Graph-based\nRetrieval-Augmented Generation framework that automatically converts enterprise\nweb applications into state-action knowledge graphs, enabling LLMs to generate\ngrounded and context-aware assistance. The framework was co-developed with the\nAI enterprise RAKAM, in collaboration with Lemon Learning. We detail the\nengineering pipeline that extracts and structures software interfaces, the\ndesign of the graph-based retrieval process, and the integration of our\napproach into production DAP workflows. Finally, we discuss scalability,\nrobustness, and deployment lessons learned from industrial use cases.",
      "url": "http://arxiv.org/abs/2511.05297v1",
      "published_time_eastern_timestamp": 1762527405.0
    },
    {
      "title": "Language Generation and Identification From Partial Enumeration: Tight\n  Density Bounds and Topological Characterizations",
      "summary": "The success of large language models (LLMs) has motivated formal theories of\nlanguage generation and learning. We study the framework of \\emph{language\ngeneration in the limit}, where an adversary enumerates strings from an unknown\nlanguage $K$ drawn from a countable class, and an algorithm must generate\nunseen strings from $K$. Prior work showed that generation is always possible,\nand that some algorithms achieve positive lower density, revealing a\n\\emph{validity--breadth} trade-off between correctness and coverage. We resolve\na main open question in this line, proving a tight bound of $1/2$ on the best\nachievable lower density. We then strengthen the model to allow \\emph{partial\nenumeration}, where the adversary reveals only an infinite subset $C \\subseteq\nK$. We show that generation in the limit remains achievable, and if $C$ has\nlower density $\\alpha$ in $K$, the algorithm's output achieves density at least\n$\\alpha/2$, matching the upper bound. This generalizes the $1/2$ bound to the\npartial-information setting, where the generator must recover within a factor\n$1/2$ of the revealed subset's density. We further revisit the classical\nGold--Angluin model of \\emph{language identification} under partial\nenumeration. We characterize when identification in the limit is possible --\nwhen hypotheses $M_t$ eventually satisfy $C \\subseteq M \\subseteq K$ -- and in\nthe process give a new topological formulation of Angluin's characterization,\nshowing that her condition is precisely equivalent to an appropriate\ntopological space having the $T_D$ separation property.",
      "url": "http://arxiv.org/abs/2511.05295v1",
      "published_time_eastern_timestamp": 1762527364.0
    },
    {
      "title": "Reflective Personalization Optimization: A Post-hoc Rewriting Framework\n  for Black-Box Large Language Models",
      "summary": "The personalization of black-box large language models (LLMs) is a critical\nyet challenging task. Existing approaches predominantly rely on context\ninjection, where user history is embedded into the prompt to directly guide the\ngeneration process. However, this single-step paradigm imposes a dual burden on\nthe model: generating accurate content while simultaneously aligning with\nuser-specific styles. This often results in a trade-off that compromises output\nquality and limits precise control. To address this fundamental tension, we\npropose Reflective Personalization Optimization (RPO), a novel framework that\nredefines the personalization paradigm by decoupling content generation from\nalignment. RPO operates in two distinct stages: first, a base model generates a\nhigh-quality, generic response; then, an external reflection module explicitly\nrewrites this output to align with the user's preferences. This reflection\nmodule is trained using a two-stage process. Initially, supervised fine-tuning\nis employed on structured rewriting trajectories to establish a core\npersonalized reasoning policy that models the transformation from generic to\nuser-aligned responses. Subsequently, reinforcement learning is applied to\nfurther refine and enhance the quality of the personalized outputs.\nComprehensive experiments on the LaMP benchmark demonstrate that RPO, by\ndecoupling content generation from personalization, significantly outperforms\nstate-of-the-art baselines. These findings underscore the superiority of\nexplicit response shaping over implicit context injection. Moreover, RPO\nintroduces an efficient, model-agnostic personalization layer that can be\nseamlessly integrated with any underlying base model, paving the way for a new\nand effective direction in user-centric generation scenarios.",
      "url": "http://arxiv.org/abs/2511.05286v1",
      "published_time_eastern_timestamp": 1762526929.0
    },
    {
      "title": "TAMAS: Benchmarking Adversarial Risks in Multi-Agent LLM Systems",
      "summary": "Large Language Models (LLMs) have demonstrated strong capabilities as\nautonomous agents through tool use, planning, and decision-making abilities,\nleading to their widespread adoption across diverse tasks. As task complexity\ngrows, multi-agent LLM systems are increasingly used to solve problems\ncollaboratively. However, safety and security of these systems remains largely\nunder-explored. Existing benchmarks and datasets predominantly focus on\nsingle-agent settings, failing to capture the unique vulnerabilities of\nmulti-agent dynamics and co-ordination. To address this gap, we introduce\n$\\textbf{T}$hreats and $\\textbf{A}$ttacks in $\\textbf{M}$ulti-$\\textbf{A}$gent\n$\\textbf{S}$ystems ($\\textbf{TAMAS}$), a benchmark designed to evaluate the\nrobustness and safety of multi-agent LLM systems. TAMAS includes five distinct\nscenarios comprising 300 adversarial instances across six attack types and 211\ntools, along with 100 harmless tasks. We assess system performance across ten\nbackbone LLMs and three agent interaction configurations from Autogen and\nCrewAI frameworks, highlighting critical challenges and failure modes in\ncurrent multi-agent deployments. Furthermore, we introduce Effective Robustness\nScore (ERS) to assess the tradeoff between safety and task effectiveness of\nthese frameworks. Our findings show that multi-agent systems are highly\nvulnerable to adversarial attacks, underscoring the urgent need for stronger\ndefenses. TAMAS provides a foundation for systematically studying and improving\nthe safety of multi-agent LLM systems.",
      "url": "http://arxiv.org/abs/2511.05269v1",
      "published_time_eastern_timestamp": 1762525826.0
    },
    {
      "title": "Translation via Annotation: A Computational Study of Translating\n  Classical Chinese into Japanese",
      "summary": "Ancient people translated classical Chinese into Japanese by annotating\naround each character. We abstract this process as sequence tagging tasks and\nfit them into modern language technologies. The research of this annotation and\ntranslation system is a facing low-resource problem. We release this problem by\nintroducing a LLM-based annotation pipeline and construct a new dataset from\ndigitalized open-source translation data. We show that under the low-resource\nsetting, introducing auxiliary Chinese NLP tasks has a promoting effect on the\ntraining of sequence tagging tasks. We also evaluate the performance of large\nlanguage models. They achieve high scores in direct machine translation, but\nthey are confused when being asked to annotate characters. Our method could\nwork as a supplement of LLMs.",
      "url": "http://arxiv.org/abs/2511.05239v1",
      "published_time_eastern_timestamp": 1762523176.0
    },
    {
      "title": "Effectiveness of Chain-of-Thought in Distilling Reasoning Capability\n  from Large Language Models",
      "summary": "Chain-of-Thought (CoT) prompting is a widely used method to improve the\nreasoning capability of Large Language Models (LLMs). More recently, CoT has\nbeen leveraged in Knowledge Distillation (KD) to transfer reasoning capability\nfrom a larger LLM to a smaller one. This paper examines the role of CoT in\ndistilling the reasoning capability from larger LLMs to smaller LLMs using\nwhite-box KD, analysing its effectiveness in improving the performance of the\ndistilled models for various natural language reasoning and understanding\ntasks. We conduct white-box KD experiments using LLMs from the Qwen and Llama2\nfamilies, employing CoT data from the CoT-Collection dataset. The distilled\nmodels are then evaluated on natural language reasoning and understanding tasks\nfrom the BIG-Bench-Hard (BBH) benchmark, which presents complex challenges for\nsmaller LLMs. Experimental results demonstrate the role of CoT in improving\nwhite-box KD effectiveness, enabling the distilled models to achieve better\naverage performance in natural language reasoning and understanding tasks from\nBBH.",
      "url": "http://arxiv.org/abs/2511.05184v1",
      "published_time_eastern_timestamp": 1762517139.0
    },
    {
      "title": "Generating Software Architecture Description from Source Code using\n  Reverse Engineering and Large Language Model",
      "summary": "Software Architecture Descriptions (SADs) are essential for managing the\ninherent complexity of modern software systems. They enable high-level\narchitectural reasoning, guide design decisions, and facilitate effective\ncommunication among diverse stakeholders. However, in practice, SADs are often\nmissing, outdated, or poorly aligned with the system's actual implementation.\nConsequently, developers are compelled to derive architectural insights\ndirectly from source code-a time-intensive process that increases cognitive\nload, slows new developer onboarding, and contributes to the gradual\ndegradation of clarity over the system's lifetime. To address these issues, we\npropose a semi-automated generation of SADs from source code by integrating\nreverse engineering (RE) techniques with a Large Language Model (LLM). Our\napproach recovers both static and behavioral architectural views by extracting\na comprehensive component diagram, filtering architecturally significant\nelements (core components) via prompt engineering, and generating state machine\ndiagrams to model component behavior based on underlying code logic with\nfew-shots prompting. This resulting views representation offer a scalable and\nmaintainable alternative to traditional manual architectural documentation.\nThis methodology, demonstrated using C++ examples, highlights the potent\ncapability of LLMs to: 1) abstract the component diagram, thereby reducing the\nreliance on human expert involvement, and 2) accurately represent complex\nsoftware behaviors, especially when enriched with domain-specific knowledge\nthrough few-shot prompting. These findings suggest a viable path toward\nsignificantly reducing manual effort while enhancing system understanding and\nlong-term maintainability.",
      "url": "http://arxiv.org/abs/2511.05165v1",
      "published_time_eastern_timestamp": 1762515346.0
    },
    {
      "title": "Mind the Gap... or Not? How Translation Errors and Evaluation Details\n  Skew Multilingual Results",
      "summary": "Most current large language models (LLMs) support a wide variety of languages\nin addition to English, including high-resource languages (e.g. German,\nChinese, French), as well as low-resource ones (e.g. Swahili, Telugu). In\naddition they have also shown impressive capabilities in different domains,\nlike coding, science and math. In this short paper, taking math as an example\ndomain, we study the performance of different LLMs across languages.\nExperimental results show that there exists a non-negligible and consistent gap\nin the performance of the models across languages. Interestingly, and somewhat\nagainst expectations, the gap exists for both high- and low-resource languages.\nWe hope that these results influence further research into cross-lingual\ncapability generalization for next generation LLMs. If it weren't for the fact\nthat they are false! By analyzing one of the standard multilingual math\nbenchmarks (MGSM), we determine that several translation errors are present in\nthe data. Furthermore, the lack of standardized answer extraction from LLM\noutputs further influences the final results. We propose a method for automatic\nquality assurance to address the first issue at scale, and give recommendations\nto address the second one. Combining these two approaches we show that the\naforementioned language gap mostly disappears, leading to completely different\nconclusions from our research. We additionally release the corrected dataset to\nthe community.",
      "url": "http://arxiv.org/abs/2511.05162v1",
      "published_time_eastern_timestamp": 1762515010.0
    },
    {
      "title": "A Toolbox for Improving Evolutionary Prompt Search",
      "summary": "Evolutionary prompt optimization has demonstrated effectiveness in refining\nprompts for LLMs. However, existing approaches lack robust operators and\nefficient evaluation mechanisms. In this work, we propose several key\nimprovements to evolutionary prompt optimization that can partially generalize\nto prompt optimization in general: 1) decomposing evolution into distinct steps\nto enhance the evolution and its control, 2) introducing an LLM-based judge to\nverify the evolutions, 3) integrating human feedback to refine the evolutionary\noperator, and 4) developing more efficient evaluation strategies that maintain\nperformance while reducing computational overhead. Our approach improves both\noptimization quality and efficiency. We release our code, enabling prompt\noptimization on new tasks and facilitating further research in this area.",
      "url": "http://arxiv.org/abs/2511.05120v1",
      "published_time_eastern_timestamp": 1762509881.0
    }
  ]
}